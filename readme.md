# ðŸª£ emmer
[![Go Report Card](https://goreportcard.com/badge/github.com/TimoKats/emmer)](https://goreportcard.com/report/github.com/TimoKats/emmer)
[![Tests](https://github.com/TimoKats/emmer/actions/workflows/test.yaml/badge.svg)](https://github.com/TimoKats/emmer/actions/workflows/test.yaml)
[![License: EUPL](https://img.shields.io/badge/license-EUPL-blue.svg)](https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12)

As self-hosted API for CRUD-ing JSON data on different filesystems (local, S3, azure blob, ...). Built for data storage in small personal projects, or mocking an API for development. You can install emmer with the command below. After that, you can run `emmer` to start.

```console
foo@bar:~$ go install github.com/TimoKats/emmer@latest
foo@bar:~$ emmer
2025/09/10 16:41:20 set username to: admin
2025/09/10 16:41:20 set password to: ************
2025/09/10 16:41:20 selected local fs in: /home/user/.emmer
2025/09/10 16:41:20 server is running on http://localhost:8080
```

The API is based on your JSON structure. So the example below is for CRUD-ing `[key1][key2]` in `file.json`. The value (which can be anything) is then added to the body of the request. Moreover, there are helper functions for appending and incrementing values. 

```
DELETE/PUT/GET: /api/file/key1/key2/...
```

<details>
<summary>Examples</summary>
<hr />

In this example, we will use emmer to create a small database for blogs and comments. Note, username/password for (required) basic auth is generated on startup, or set environment variables.

1: Do a PUT request to <code>/api/posts</code> with body shown below to create a json file we can start with.

```json
{
  "article1": {"text": "Here I write my article"}
}
```

2: Query your json file with GET requests. For example, sending a GET request to <code>/api/posts/article1/text</code> will return the text field of post1.

```json
"Here I write my article"
```

3: Continously add comments to our posts. This would probably be a list of "comment" objects. Emmer handles this by adding the "append" parameter to our PUT request. For example, the comment (shown below) is sent to <code>/api/posts/post1/comments?mode=append</code>.

```json
{"comment": "great stuff", "username": "timo"}
```

4: Do a GET request to <code>/api/posts/post1/comments</code>/ to fetch all comments. Note, you can do the PUT request from step 3 again to keep adding comments to your article.

```json
[{"comment": "great stuff", "username": "timo"}]
```

5: Send a DELETE request to <code>/api/posts</code> to delete the json file. This complete json file should look (something) like this:

```json
{
    "post1": {
        "comments": [{"comment": "not great stuff", "username": "tomi"}, {"comment": "great stuff", "username": "timo"}],
        "text": "Here I write my article"
    }
}

```

</details>

<details>
<summary>Docs</summary>
<hr />

<b>Endpoints</b>
 - /api/\<json\>/\<path\>/...: Send PUT/DEL/GET requests here to edit your json data.
 - /logs: Shows last _n_ logs generated by emmer
 - /ping: Health check of emmer. Bypasses authentication.

<b>Parameters</b>
- mode: increment. If you access a numeric value, adding increment parameter will increase it by 1. Note, if you put a numeric value in your body (-1, 2, etc) then that's added to the numeric value instead.
- mode: append. Using the append mode, you can append objects (that you put in your request body) to a json list. Note, if the json key doesn't exist (or is not a list), this mode will do that conversion automatically.

<b>Environment variables</b>
- EM_AUTOTABLE: Set to false if you DON'T want to automatically create a new file when adding an entry.
- EM_USERNAME: Username of basic auth for API. Auto generated if empty.
- EM_PASSWORD: Password of basic auth for API. Auto generated if empty
- EM_FILESYSTEM: Local, AWS, etc. Not useful now, since I've only implemented local.
- EM_FOLDER: When using local FS, this sets the folder emmer writes files to. Default: $HOME/.local/share/emmer (or XDG_DATA_HOME) (AppData on Windows).

<b>Flags</b>
- -p: sets the port to run on. Default is 8080.
  
</details>
